// services/blockchainService.js
// Imports Ethers.js library for blockchain interaction
const ethers = require('ethers');

// --- CRITICAL TEMPORARY FIX: Prevents crash if ISSUE_PRIVATE_KEY is missing/invalid ---
// This key will only be used if the real key in .env is not defined or too short.
const DUMMY_PRIVATE_KEY = '0x1111111111111111111111111111111111111111111111111111111111111111';

// ABI placeholder: This must match the Solidity contract exactly.
const CERT_CONTRACT_ABI = [
    "function issueCertificate(bytes32 certificateHash) public",
    "function getIssuer(bytes32 certificateHash) view returns (address)" // For verification
];

// Determine the private key to use: the real one, or the dummy one for compilation
const privateKey = process.env.ISSUER_PRIVATE_KEY && process.env.ISSUER_PRIVATE_KEY.length >= 64
    ? process.env.ISSUER_PRIVATE_KEY
    : DUMMY_PRIVATE_KEY; 


// --- 1. SETUP PROVIDER and SIGNER ---
// Accesses the necessary provider component using the correct Ethers v6+ structure.
const provider = new ethers.JsonRpcProvider(process.env.POLYGON_RPC_URL);
const signer = new ethers.Wallet(privateKey, provider);

// --- 2. SETUP CONTRACT INSTANCE ---
// Instantiates the contract object using the address, ABI, and the signer (Institution wallet)
const contract = new ethers.Contract(
    process.env.SMART_CONTRACT_ADDRESS,
    CERT_CONTRACT_ABI,
    signer 
);

/**
 * @desc Sends the certificate hash to the Smart Contract for immutable recording (Write Transaction).
 * @param {string} certificateHash - The SHA256 hash generated by the controller.
 */
exports.recordHash = async (certificateHash) => {
    try {
        console.log(`[BLOCKCHAIN] Sending hash to contract...`);
        
        // 1. Convert hash (string) to the required Solidity bytes32 format
        const bytes32Hash = ethers.utils.formatBytes32String(certificateHash.padEnd(32, '\0'));
        
        // 2. Execute the write transaction on the blockchain
        const transaction = await contract.issueCertificate(
            bytes32Hash,
            { gasLimit: 300000 } // Specify gas limit for reliable Testnet transaction
        );
        
        // 3. Wait for the transaction to be mined and confirmed
        const receipt = await transaction.wait(); 
        
        console.log(`[BLOCKCHAIN] Transaction successful! Hash: ${receipt.transactionHash}`);
        
        return {
            success: true,
            transactionHash: receipt.transactionHash,
            blockNumber: receipt.blockNumber
        };

    } catch (error) {
        console.error("BLOCKCHAIN TRANSACTION FAILED:", error);
        // Throw a custom error to be caught and handled gracefully by the controller
        throw new Error("Failed to record hash on blockchain.");
    }
};

/**
 * @desc Queries the blockchain to check if a hash has been recorded (Read Call).
 */
exports.verifyHash = async (certificateHash) => {
    try {
        // FIX: Access utility function directly (v6+ fix: encodeBytes32String)
        const bytes32Hash = ethers.encodeBytes32String(certificateHash.padEnd(32, '\0'));


        const contractReader = new ethers.Contract(
            process.env.SMART_CONTRACT_ADDRESS,
            CERT_CONTRACT_ABI,
            provider // Use the provider (read-only) for better performance
        );
        
        // This is a "view" function, meaning it doesn't send a transaction or cost gas.
        const issuerAddress = await contract.getIssuer(bytes32Hash);

        // Check if the returned address is the zero address (0x00...00).
        const isRecorded = issuerAddress !== ethers.constants.AddressZero;

        return {
            isRecorded: isRecorded,
            issuerAddress: issuerAddress
        };
        
    } catch (error) {
        console.error("BLOCKCHAIN VERIFICATION FAILED:", error);
        throw new Error("Failed to verify hash on blockchain.");
    }
};